# Redux-Counter
* 2020-06-26 
* 프로젝트 출처 : https://velopert.com/3346
* Redux 순수함수 개념 출처 : https://www.vobour.com/%EB%A6%AC%EB%8D%95%EC%8A%A4-redux-%EC%9D%98-%EB%A6%AC%EB%93%80%EC%84%9C-reducer-%EA%B0%80-%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%97%AC%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0

#### Redux의 Reducer는 왜 언제나 순수함수로 이루어져야 할까?

* 순수함수(pure function)<br/>
: 기본적으로 데이터를 변경하지 않고 외부상태(DB, Dom 또는 전역변수)에 의존하지 않으며<br/>
동일한 입력값에 대해 동일한 출력값을 일관되게 제공하는 함수를 말한다.

* Redux는 주어진 상태(객체) == state를 가져와서 loop의 각 Reducer로 전달한다.<br/>
그리고 변경사항이 있는 경우, Reducer의 새로운 객체를 return하고<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;변경사항이 없는 경우, 이전객체를 리턴한다.<br/>
즉 변경사항이 없다면 이전 객체를 그대로 되돌려 보내고<br/>
새로운 객체는 새로운 상태를 나타냄.
<br/>
<br/>
Redux는 두 객체의 메모리 위치를 비교하여 이전 객체가 새 객체와 동일한지 여부를 위치값으로 체크하기 때문에<br/>
Reducer 내부에서 이전 객체의 속성을 변경(mutate)하면 "새상태"와 "이전상태"가 모두 동일한 객체를 가리킨다.<br/>
Redux는 이것을 아무것도 변경되지 않았다고 생각하고 이전 객체를 그대로 리턴하기 때문에 아무런 일도 일어나지 않는 것처럼 보인다.

#### 1. Redux는 왜 이렇게 설계 되었을까?<br/> 2. Redux가 이전 상태 값을 다른곳으로 복사한 다음, Reducer의 객체 props를 비교할 수 없는 이유는 뭘까?<br/>3. Redux가 개발자에게 이러한 부담을 주는 이유는 무엇일까?
>* 두개의 자바스크립트 객체가 동일한 속성을 가지고 있는지를 아는 단 한가지 방법은 이 두 객체를 깊이 비교 해야하는 것 뿐인데<br/>
객체가 크거나 비교해야하는 횟수가 많으면 실제 앱에서는 매우 무거운 작업이 되기 때문임.<br/>
따라서 변경사항이 있을 때마다 새 객체를 만들어 프레임워크로 보내도록 하는 정책을 만들었음<br/>
(push()와 같은 함수 대신 이전상태를 복제해 이전값을 새 객체로 복사해 리턴하는 slice() 함수를 사용해야하는 이유)<br/>

>* 이러한 정책을 적용하면 객체의 각 속성의 비교 없이 !== 를 사용해 두 객체의 메모리 위치값만을 비교해 객체의 상태가 변경되었는지를 비교 할 수 있다.<br/>


#### Action



#### Store 만들기
* Store는 현재상태를 내장하고 있고, subscribe 중인 함수들이 상태가 업데이트 될 때마다 다시 실행되게 해준다.<br/>
Store를 만들때는 redux에서 createStore를 불러온 다음,<br/>
해당함수의 파라메터값으로 Reducer를 넣어주면 된다.<br/>
<br/>
index.js에 redux로부터 createStore를 import 해주고, reducers 디렉토리를 import







 
 